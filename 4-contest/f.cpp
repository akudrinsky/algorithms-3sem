/*
–°–µ–≥–æ–¥–Ω—è –Ω–∞ —É—Ä–æ–∫–µ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å –ú–∞—Å—Å–∏–≤–æ–≤ –ê–≤—Ç–æ–º–∞—Ç –£–∫–∫–æ–Ω–µ–≤–∏—á —Ä–∞—Å—Å–∫–∞–∑—ã–≤–∞–ª —Å–≤–æ–∏–º —É—á–µ–Ω–∏–∫–∞–º –ø—Ä–æ —Å—Ç—Ä–æ–∫–∏, —Å—É—Ñ—Ñ–∏–∫—Å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ –≤—Å—ë —Ç–∞–∫–æ–µ. –ù–∞–ø—Ä–∏–º–µ—Ä, –æ–Ω —Ä–∞—Å—Å–∫–∞–∑–∞–ª –∏–º, –∫–∞–∫ —Å—Ä–∞–≤–Ω–∏—Ç—å –¥–≤–µ —Å—Ç—Ä–æ–∫–∏ ùê¥ –∏ ùêµ –ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏. –ï—Å–ª–∏ –æ–¥–Ω–∞ –∏–∑ –Ω–∏—Ö —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–µ—Ñ–∏–∫—Å–æ–º –¥—Ä—É–≥–æ–π, —Ç–æ –±–æ–ª–µ–µ –∫–æ—Ä–æ—Ç–∫–∞—è –±—É–¥–µ—Ç –ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ –º–µ–Ω—å—à–µ, –∏–Ω–∞—á–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Å—Ä–∞–≤–Ω–∏—Ç—å —Å–∏–º–≤–æ–ª—ã —Å—Ç–æ—è—â–∏–µ –Ω–∞ –ø–µ—Ä–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏, –≤ –∫–æ—Ç–æ—Ä–æ–π –æ–Ω–∏ –æ—Ç–ª–∏—á–∞—é—Ç—Å—è. –°—Ç—Ä–æ–∫–∞ —Å –º–µ–Ω—å—à–∏–º –ø–æ –Ω–æ–º–µ—Ä—É –≤ –∞–ª—Ñ–∞–≤–∏—Ç–µ —Å–∏–º–≤–æ–ª–æ–º –Ω–∞ –¥–∞–Ω–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ –∏ –±—É–¥–µ—Ç –ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ –º–µ–Ω—å—à–µ.

–ß—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–Ω–∏–º–∞–Ω–∏–µ —É—á–µ–Ω–∏–∫–∞–º–∏ –Ω–æ–≤–æ–≥–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞, –ê–≤—Ç–æ–º–∞—Ç –£–∫–∫–æ–Ω–µ–≤–∏—á –¥–∞–ª –∏–º —Å–ª–µ–¥—É—é—â–µ–µ –∑–∞–¥–∞–Ω–∏–µ: –Ω–∞–π—Ç–∏ ùëò-—é –ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ –Ω–µ–ø—É—Å—Ç—É—é —É–Ω–∏–∫–∞–ª—å–Ω—É—é –ø–æ–¥—Å—Ç—Ä–æ–∫—É —Å—Ç—Ä–æ–∫–∏ ùëÜ.

–¢–∞–∫ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å –∑–Ω–∞–µ—Ç, —á—Ç–æ –ê–ª–µ–∫—Å–∞–Ω–¥—Ä –ì. –∏ –ò–ª—å—è –°. –æ—á–µ–Ω—å –ª—é–±—è—Ç —Å–ø–∏—Å—ã–≤–∞—Ç—å —É –∏–∑–≤–µ—Å—Ç–Ω–æ–≥–æ –≤ —É–∑–∫–∏—Ö –∫—Ä—É–≥–∞—Ö –î–µ–º–∏–¥–∞ –ì., –∫–∞–∂–¥—ã–π —à–∫–æ–ª—å–Ω–∏–∫ –ø–æ–ª—É—á–∏–ª —Å–≤–æ—ë —á–∏—Å–ª–æ ùëò –∏ –≤—ã–Ω—É–∂–¥–µ–Ω –±—ã–ª –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –≤–∞–º –∑–∞ –ø–æ–º–æ—â—å—é.

–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–í –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è —Å—Ç—Ä–æ–∫–∞ ùëÜ (|ùëÜ|‚â§105). –í—Ç–æ—Ä–∞—è —Å—Ç—Ä–æ–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç —á–∏—Å–ª–æ ùëò (1‚â§ùëò‚â§1018) ‚Äî –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º–æ–π –ø–æ–¥—Å—Ç—Ä–æ–∫–∏.

–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–ï—Å–ª–∏ –æ—Ç–≤–µ—Ç —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –≤—ã–≤–µ–¥–∏—Ç–µ –∏—Å–∫–æ–º—É—é –ø–æ–¥—Å—Ç—Ä–æ–∫—É —Å—Ç—Ä–æ–∫–∏ ùëÜ. –í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –≤—ã–≤–µ–¥–∏—Ç–µ –µ—ë –ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –ø–æ–¥—Å—Ç—Ä–æ–∫—É.
*/

#include <cstdio>
#include <cstring>
#include <vector>
#include <stack>
#include <string>
#include <iostream>

#ifdef DEBUG
    #define LOGS(...)\
        fprintf(stderr, "-----LOG-----\n~~~~~~~~~~~~~\n");\
        fprintf(stderr, __VA_ARGS__);\
        fprintf(stderr, "\n~~~~~~~~~~~~~\nFILE: %s\nLINE: %d\nFUNC: %s", __FILE__, __LINE__, __func__);\
        fprintf(stderr, "\n---LOG-END---\n\n\n\n");
    #define ON_DEBUG(...)\
        __VA_ARGS__
#else
    #define LOGS(...) ;
    #define ON_DEBUG(...)\
        ;
#endif

#define INTERNAL(line) //fprintf(stderr, "ITER: %d on line %d\n", i, line);\

/*
        for (int j = 0; j < allData.size(); ++j)\
        {\
            fprintf(stderr, "stack[%d] = %d\n", j, stack[j]);\
        }\
        for (int j = 0; j < nStrings; ++j)\
        {\
            fprintf(stderr, "answer[%d] = %d\n", j, answer[j]);\
        }\
        for (int j = 0; j < allData.size(); ++j)\
        {\
            fprintf(stderr, "left[%d] = %d\n", j, leftBorders[j]);\
        }\
*/

class SuffixArray
{
public:
    struct LightArray
    {
        int* data;
        int len;
        ~LightArray();
    };

    SuffixArray(const char* data);

    ~SuffixArray();

    LightArray GetSuffixArray();

    LightArray GetLCP();

private:
    static const int alphabetSize = 256;
    const char* data;
    int* sortedSuffIndexes;
    int* classIndexes;
    int nClasses;
    int len;

    void zeroPhaze(const char* data);

    void printInternal(int lineNum);

    void phaze(int phazeID);
};

class FenwickForSum 
{
public:
    std::vector<int> data;
    std::vector<int> fenwick;

    FenwickForSum (int maxLen);

    void Add(int x, int val, int total_length);

    int Sum(int x);

    int Query(int left, int right);
};

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//-------------------------------------MAIN-------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

int main()
{
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    unsigned long long nStrings = 0;
    std::string allData;

    std::cin >> nStrings;
    std::vector<int> dollars(nStrings, 0);
    //int totalLen = 0;

    int* stringIDs = new int[400000];

    for (int i = 0; i < nStrings; ++i)
    {
        std::string mini;
        std::cin >> mini;
        for (int j = 0; j < mini.size(); ++j)
        {
            stringIDs[allData.size() + j] = i;
        }
        stringIDs[allData.size() + mini.size() + 1] = 0;
        allData += mini;
        dollars[i] = allData.size();
        allData += "$";
    }

    /*
    fprintf(stderr, "stringIDs[i]\n");
    for (int i = 0; i < allData.size(); ++i)
    {
        fprintf(stderr, "stringIDs[%d] = %d\n", i, stringIDs[i]);
    }
    */

    SuffixArray solver(allData.c_str());

    auto lcp = solver.GetLCP();
    auto suffArray = solver.GetSuffixArray();

    for (int i = 0; i < lcp.len; ++i)
    {
        if (allData[suffArray.data[i]] == '$' || lcp.data[i] == -1 || allData[suffArray.data[i]] == '\0')
        {
            lcp.data[i] = 0;
            continue;
        }
        int suffID = stringIDs[suffArray.data[i]];
        //int nextSuffId = stringIDs[suffArray.data[i + 1]];
        //printf("%d (%d) - %d\n", dollars[suffID], suffID, suffArray.data[i]);
        lcp.data[i] = std::min(lcp.data[i], dollars[suffID] - suffArray.data[i]);
        //lcp.data[i] = std::min(lcp.data[i], dollars[nextSuffId + 1] - suffArray.data[i]);
    }

    int first = suffArray.data[0];
    for (int i = 0; i < suffArray.len - 1; ++i)
    {
        suffArray.data[i] = suffArray.data[i + 1];
    }
    suffArray.data[suffArray.len - 1] = 0;

    /*
    printf("sortedSuffIndexes\n");
    for (int i = 0; i < lcp.len; ++i)
    {
        printf("%3d) [id %3d, %3d common] %s\n", i, suffArray.data[i], lcp.data[i], allData.c_str() + suffArray.data[i]);
    }
    printf("\n\n");
    */

    int* answer = new int[400000];
    int* stack = new int[400000];
    int* leftBorders = new int[400000];

    for (int i = 0; i < allData.size(); ++i)
    {
        answer[i] = 0;
        stack[i] = 0;
        leftBorders[i] = 0;
    }

    FenwickForSum fnwk(400000);
    int stackPtr = 1;
    for (int i = 1; i <= allData.size(); ++i)
    {
        //if (i <= 14) fprintf(stderr, "Iter %d\n", i);
        //if (i <= 14) {INTERNAL(__LINE__)}
        while (lcp.data[i] < lcp.data[stack[stackPtr - 1]])
        {
            //fprintf(stderr, "left[stack[ss - 1]] = %d, stack[ss - 1] = %d, ss = %d\n", leftBorders[stack[stackPtr - 1]], stack[stackPtr - 1], stackPtr);

            int nDistinct = fnwk.Query(leftBorders[stack[stackPtr - 1]], i - 1);

            //fprintf(stderr, "nDistinct = %d\n", nDistinct);

            if (lcp.data[stack[stackPtr - 1]] > answer[nDistinct])
            {
                answer[nDistinct] = lcp.data[stack[stackPtr - 1]];
            }
            --stackPtr;
        }
        if (i <= 14) {INTERNAL(__LINE__)}

        if (lcp.data[stack[stackPtr - 1]] == lcp.data[i])
        {
            leftBorders[i] = leftBorders[stack[stackPtr - 1]];
        }
        else 
        {
            leftBorders[i] = stack[stackPtr - 1];
        }

        stack[stackPtr++] = i;
        if (i <= 14) {INTERNAL(__LINE__)}
        if (fnwk.data[stringIDs[suffArray.data[i]]])
        {
            fnwk.Add(fnwk.data[stringIDs[suffArray.data[i]]], -1, allData.size());
        }

        if (i <= 14) {INTERNAL(__LINE__)}
        fnwk.Add(i, 1, allData.size());
        fnwk.data[stringIDs[suffArray.data[i]]] = i;
    }

    for (int i = nStrings - 1; i >= 2; i--) {
        if (answer[i + 1] > answer[i]) {
            answer[i] = answer[i + 1];
        }
    }

    for (int i = 2; i <= nStrings; ++i)
    {
        std::cout << answer[i] << '\n';
    }

    delete [] answer;
    delete [] stack;
    delete [] leftBorders;
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//-------------------------------------IMPL-------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

SuffixArray::SuffixArray(const char* data)
    :
    nClasses(0),
    data(data)
{
    len = strlen(data) + 1;
    sortedSuffIndexes = new int[len];
    classIndexes = new int[len];

    zeroPhaze(data);

    for (int phazeID = 0; (1 << phazeID) < len; ++phazeID)
    {
        phaze(phazeID);
    }
    //ON_DEBUG(printInternal(__LINE__);)
}

void SuffixArray::zeroPhaze(const char* data)
{
    int counter[alphabetSize] = {};

    // count elements by value
    for (int i = 0; i < len; ++i)
    {
        ++counter[data[i]];
    }

    // change to indexes range
    for (int i = 1; i < alphabetSize; ++i)
    {    
        counter[i] += counter[i - 1];
    }

    // get permutation 
    // <<sortedSuffIndexes[i] = j>> == <<i'th elem in data is j'th in sorted>>
    for (int i = len - 1; i >= 0; --i)
    {
        --counter[data[i]];
        sortedSuffIndexes[counter[data[i]]] = i;
    }

    classIndexes[sortedSuffIndexes[0]] = nClasses;
    nClasses = 1;
    for (int i = 1; i < len; ++i)
    {
        if (data[sortedSuffIndexes[i]] != data[sortedSuffIndexes[i - 1]])
        {
            ++nClasses;
        }
        classIndexes[sortedSuffIndexes[i]] = nClasses - 1;
    }
}

SuffixArray::LightArray::~LightArray()
{
    //delete [] data;
    len = -1;
}

void SuffixArray::phaze(int phazeID)
{
    const int phazeLen = 1 << phazeID;
    int* sortedSuffIndexesNew = new int[len];
    int* classIndexesNew = new int[len];

    // sort by second half of string
    for (int i = 0; i < len; ++i)
    {
        sortedSuffIndexesNew[i] = sortedSuffIndexes[i] - phazeLen;
        if (sortedSuffIndexesNew[i] < 0)
        {
            sortedSuffIndexesNew[i] += len;
        }
    }

    // stable sort by first half
    int* counter = new int[len];
    memset(counter, 0, sizeof(int) * len);

    for (int i = 0; i < len; ++i)
    {
        ++counter[classIndexes[sortedSuffIndexesNew[i]]];
    }

    for (int i = 1; i < nClasses; ++i)
    {
        counter[i] += counter[i - 1];
    }

    for (int i = len - 1; i >= 0; --i)
    {
        --counter[classIndexes[sortedSuffIndexesNew[i]]];
        sortedSuffIndexes[counter[classIndexes[sortedSuffIndexesNew[i]]]] = sortedSuffIndexesNew[i];
    }

    classIndexesNew[sortedSuffIndexes[0]] = 0;
    nClasses = 1;
    for (int i = 1; i < len; ++i)
    {
        int firstStarter = (sortedSuffIndexes[i] + phazeLen) % len;
        int secondStarter = (sortedSuffIndexes[i - 1] + phazeLen) % len;
        if (classIndexes[sortedSuffIndexes[i]] != classIndexes[sortedSuffIndexes[i - 1]] 
            or classIndexes[firstStarter] != classIndexes[secondStarter])
        {
            ++nClasses;
        }
        classIndexesNew[sortedSuffIndexes[i]] = nClasses - 1;
    }

    delete [] classIndexes;
    delete [] sortedSuffIndexesNew;
    delete [] counter;

    classIndexes = classIndexesNew;
}

SuffixArray::LightArray SuffixArray::GetSuffixArray()
{
    return {sortedSuffIndexes, len};
}

SuffixArray::~SuffixArray()
{
    delete [] sortedSuffIndexes;
}

void SuffixArray::printInternal(int lineNum)
{
    printf("sortedSuffIndexes at %d:\n", lineNum);
    for (int i = 0; i < len; ++i)
    {
        printf("%3d) [%3d] %s\n", i, sortedSuffIndexes[i], data + sortedSuffIndexes[i]);
    }
    printf("\n\n");
}

SuffixArray::LightArray SuffixArray::GetLCP()
{
    int* lcp = new int[len];
    int* reverseSuff = new int[len];

    for (int i = 0; i < len; ++i)
    {
        reverseSuff[sortedSuffIndexes[i]] = i;
    }

    int k = 0;
    for (int i = 0; i < len; ++i)
    {
        if (k > 0)
        {
            --k;
        }
        if (reverseSuff[i] == len - 1)
        {
            lcp[len - 1] = -1;
            k = 0;
            continue;
        }
        else
        {
            int j = sortedSuffIndexes[reverseSuff[i] + 1];
            while (std::max(i + k, j + k) < len and data[i + k] == data[j + k])
            {
                ++k;
            }
            lcp[reverseSuff[i]] = k;
        }
    }

    delete [] reverseSuff;

    /*
    ON_DEBUG(
        printf("sortedSuffIndexes\n");
        for (int i = 0; i < len; ++i)
        {
            printf("%3d) [id %3d, %3d common] %s\n", i, sortedSuffIndexes[i], lcp[i], data + sortedSuffIndexes[i]);
        }
        printf("\n\n");
    )
    */

    return {lcp, len};
}

FenwickForSum::FenwickForSum (int maxLen):
    data (maxLen, 0),
    fenwick (maxLen, 0)
{}

void FenwickForSum::Add(int x, int val, int total_length) 
{
    /*
    for (int i = 0; i < total_length; ++i)
    {
        fprintf(stderr, "%d %d\n", fenwick[i], data[i]);
    }
    */
    do {
        fenwick[x] += val;
        x += x & -x;
    } while (x <= total_length);
}

int FenwickForSum::Sum(int x) 
{
    //LOGS("SUM request")
    int strings = 0;
    while (x) {
        //LOGS(" x = %d", x)
        strings += fenwick[x];
        x &= x - 1;
    }
    return strings;
}

int FenwickForSum::Query(int left, int right) 
{
    //fprintf(stderr, "Query(%d, %d)\n", left, right);
    return Sum(right) - Sum(left - 1);
}