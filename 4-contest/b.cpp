/*
–°–µ–≥–æ–¥–Ω—è –Ω–∞ —É—Ä–æ–∫–µ –ø—Ä–µ–ø–æ–¥–∞–≤–∞—Ç–µ–ª—å –ú–∞—Å—Å–∏–≤–æ–≤ –ê–≤—Ç–æ–º–∞—Ç –£–∫–∫–æ–Ω–µ–≤–∏—á —Ä–∞—Å—Å–∫–∞–∑—ã–≤–∞–ª —Å–≤–æ–∏–º —É—á–µ–Ω–∏–∫–∞–º –ø—Ä–æ —Å—Ç—Ä–æ–∫–∏, —Å—É—Ñ—Ñ–∏–∫—Å–Ω—ã–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –∏ –≤—Å—ë —Ç–∞–∫–æ–µ. –ù–∞–ø—Ä–∏–º–µ—Ä, –æ–Ω —Ä–∞—Å—Å–∫–∞–∑–∞–ª –∏–º, –∫–∞–∫ —Å—Ä–∞–≤–Ω–∏—Ç—å –¥–≤–µ —Å—Ç—Ä–æ–∫–∏ ùê¥ –∏ ùêµ –ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏. –ï—Å–ª–∏ –æ–¥–Ω–∞ –∏–∑ –Ω–∏—Ö —è–≤–ª—è–µ—Ç—Å—è –ø—Ä–µ—Ñ–∏–∫—Å–æ–º –¥—Ä—É–≥–æ–π, —Ç–æ –±–æ–ª–µ–µ –∫–æ—Ä–æ—Ç–∫–∞—è –±—É–¥–µ—Ç –ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ –º–µ–Ω—å—à–µ, –∏–Ω–∞—á–µ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Å—Ä–∞–≤–Ω–∏—Ç—å —Å–∏–º–≤–æ–ª—ã —Å—Ç–æ—è—â–∏–µ –Ω–∞ –ø–µ—Ä–≤–æ–π –ø–æ–∑–∏—Ü–∏–∏, –≤ –∫–æ—Ç–æ—Ä–æ–π –æ–Ω–∏ –æ—Ç–ª–∏—á–∞—é—Ç—Å—è. –°—Ç—Ä–æ–∫–∞ —Å –º–µ–Ω—å—à–∏–º –ø–æ –Ω–æ–º–µ—Ä—É –≤ –∞–ª—Ñ–∞–≤–∏—Ç–µ —Å–∏–º–≤–æ–ª–æ–º –Ω–∞ –¥–∞–Ω–Ω–æ–π –ø–æ–∑–∏—Ü–∏–∏ –∏ –±—É–¥–µ—Ç –ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ –º–µ–Ω—å—à–µ.

–ß—Ç–æ–±—ã –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–Ω–∏–º–∞–Ω–∏–µ —É—á–µ–Ω–∏–∫–∞–º–∏ –Ω–æ–≤–æ–≥–æ –º–∞—Ç–µ—Ä–∏–∞–ª–∞, –ê–≤—Ç–æ–º–∞—Ç –£–∫–∫–æ–Ω–µ–≤–∏—á –¥–∞–ª –∏–º —Å–ª–µ–¥—É—é—â–µ–µ –∑–∞–¥–∞–Ω–∏–µ: –Ω–∞–π—Ç–∏ ùëò-—é –ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ –Ω–µ–ø—É—Å—Ç—É—é —É–Ω–∏–∫–∞–ª—å–Ω—É—é –ø–æ–¥—Å—Ç—Ä–æ–∫—É —Å—Ç—Ä–æ–∫–∏ ùëÜ.

–¢–∞–∫ –∫–∞–∫ —É—á–∏—Ç–µ–ª—å –∑–Ω–∞–µ—Ç, —á—Ç–æ –ê–ª–µ–∫—Å–∞–Ω–¥—Ä –ì. –∏ –ò–ª—å—è –°. –æ—á–µ–Ω—å –ª—é–±—è—Ç —Å–ø–∏—Å—ã–≤–∞—Ç—å —É –∏–∑–≤–µ—Å—Ç–Ω–æ–≥–æ –≤ —É–∑–∫–∏—Ö –∫—Ä—É–≥–∞—Ö –î–µ–º–∏–¥–∞ –ì., –∫–∞–∂–¥—ã–π —à–∫–æ–ª—å–Ω–∏–∫ –ø–æ–ª—É—á–∏–ª —Å–≤–æ—ë —á–∏—Å–ª–æ ùëò –∏ –≤—ã–Ω—É–∂–¥–µ–Ω –±—ã–ª –æ–±—Ä–∞—Ç–∏—Ç—å—Å—è –∫ –≤–∞–º –∑–∞ –ø–æ–º–æ—â—å—é.

–í—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–í –ø–µ—Ä–≤–æ–π —Å—Ç—Ä–æ–∫–µ –≤—Ö–æ–¥–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è —Å—Ç—Ä–æ–∫–∞ ùëÜ (|ùëÜ|‚â§105). –í—Ç–æ—Ä–∞—è —Å—Ç—Ä–æ–∫–∞ —Å–æ–¥–µ—Ä–∂–∏—Ç —á–∏—Å–ª–æ ùëò (1‚â§ùëò‚â§1018) ‚Äî –ø–æ—Ä—è–¥–∫–æ–≤—ã–π –Ω–æ–º–µ—Ä –∑–∞–ø—Ä–∞—à–∏–≤–∞–µ–º–æ–π –ø–æ–¥—Å—Ç—Ä–æ–∫–∏.

–í—ã—Ö–æ–¥–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
–ï—Å–ª–∏ –æ—Ç–≤–µ—Ç —Å—É—â–µ—Å—Ç–≤—É–µ—Ç, –≤—ã–≤–µ–¥–∏—Ç–µ –∏—Å–∫–æ–º—É—é –ø–æ–¥—Å—Ç—Ä–æ–∫—É —Å—Ç—Ä–æ–∫–∏ ùëÜ. –í –ø—Ä–æ—Ç–∏–≤–Ω–æ–º —Å–ª—É—á–∞–µ –≤—ã–≤–µ–¥–∏—Ç–µ –µ—ë –ª–µ–∫—Å–∏–∫–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω—É—é –ø–æ–¥—Å—Ç—Ä–æ–∫—É.
*/

#include <cstdio>
#include <cstring>
#include <vector>
#include <stack>

#ifdef DEBUG
    #define LOGS(...)\
        fprintf(stderr, "-----LOG-----\n~~~~~~~~~~~~~\n");\
        fprintf(stderr, __VA_ARGS__);\
        fprintf(stderr, "\n~~~~~~~~~~~~~\nFILE: %s\nLINE: %d\nFUNC: %s", __FILE__, __LINE__, __func__);\
        fprintf(stderr, "\n---LOG-END---\n\n\n\n");
    #define ON_DEBUG(...)\
        __VA_ARGS__
#else
    #define LOGS(...) ;
    #define ON_DEBUG(...)\
        ;
#endif

class SuffixArray
{
public:
    struct LightArray
    {
        const int* data;
        int len;
        ~LightArray();
    };

    SuffixArray(const char* data);

    ~SuffixArray();

    LightArray GetSuffixArray();

    LightArray GetLCP();

private:
    static const int alphabetSize = 256;
    const char* data;
    int* sortedSuffIndexes;
    int* classIndexes;
    int nClasses;
    int len;

    void zeroPhaze(const char* data);

    void printInternal(int lineNum);

    void phaze(int phazeID);
};

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//-------------------------------------MAIN-------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

int main()
{
    unsigned long long needed = 0;
    char* input = new char[100000];
    scanf("%s", input);
    scanf("%llu", &needed);

    SuffixArray solver(input);

    auto lcp = solver.GetLCP();
    auto suffArray = solver.GetSuffixArray();

    unsigned long long currentStr = 0;
    int initialStringLen = suffArray.len - 1;
    for (int i = 1; i < suffArray.len; ++i)
    {
        LOGS("%d %d %d\n", suffArray.len, suffArray.data[i], lcp.data[i - 1])
        currentStr += (initialStringLen - suffArray.data[i]) - lcp.data[i - 1];
        LOGS("currentStr = %llu\nneeded = %llu", currentStr, needed)
        if (currentStr >= needed)
        {
            *((input + suffArray.len - 1) - (currentStr - needed)) = '\0';
            printf("%s", input + suffArray.data[i]);
            break;
        }
    }

    if (currentStr < needed)
    {
        printf("%s", input + suffArray.data[suffArray.len - 1]);
    }
        
    delete [] input;
}

//------------------------------------------------------------------------------
//------------------------------------------------------------------------------
//-------------------------------------IMPL-------------------------------------
//------------------------------------------------------------------------------
//------------------------------------------------------------------------------

SuffixArray::SuffixArray(const char* data)
    :
    nClasses(0),
    data(data)
{
    len = strlen(data) + 1;
    sortedSuffIndexes = new int[len];
    classIndexes = new int[len];

    zeroPhaze(data);

    for (int phazeID = 0; (1 << phazeID) < len; ++phazeID)
    {
        phaze(phazeID);
    }
    //ON_DEBUG(printInternal(__LINE__);)
}

void SuffixArray::zeroPhaze(const char* data)
{
    int counter[alphabetSize] = {};

    // count elements by value
    for (int i = 0; i < len; ++i)
    {
        ++counter[data[i]];
    }

    // change to indexes range
    for (int i = 1; i < alphabetSize; ++i)
    {    
        counter[i] += counter[i - 1];
    }

    // get permutation 
    // <<sortedSuffIndexes[i] = j>> == <<i'th elem in data is j'th in sorted>>
    for (int i = len - 1; i >= 0; --i)
    {
        --counter[data[i]];
        sortedSuffIndexes[counter[data[i]]] = i;
    }

    classIndexes[sortedSuffIndexes[0]] = nClasses;
    nClasses = 1;
    for (int i = 1; i < len; ++i)
    {
        if (data[sortedSuffIndexes[i]] != data[sortedSuffIndexes[i - 1]])
        {
            ++nClasses;
        }
        classIndexes[sortedSuffIndexes[i]] = nClasses - 1;
    }
}

SuffixArray::LightArray::~LightArray()
{
    //delete [] data;
    len = -1;
}

void SuffixArray::phaze(int phazeID)
{
    const int phazeLen = 1 << phazeID;
    int* sortedSuffIndexesNew = new int[len];
    int* classIndexesNew = new int[len];

    // sort by second half of string
    for (int i = 0; i < len; ++i)
    {
        sortedSuffIndexesNew[i] = sortedSuffIndexes[i] - phazeLen;
        if (sortedSuffIndexesNew[i] < 0)
        {
            sortedSuffIndexesNew[i] += len;
        }
    }

    // stable sort by first half
    int* counter = new int[len];
    memset(counter, 0, sizeof(int) * len);

    for (int i = 0; i < len; ++i)
    {
        ++counter[classIndexes[sortedSuffIndexesNew[i]]];
    }

    for (int i = 1; i < nClasses; ++i)
    {
        counter[i] += counter[i - 1];
    }

    for (int i = len - 1; i >= 0; --i)
    {
        --counter[classIndexes[sortedSuffIndexesNew[i]]];
        sortedSuffIndexes[counter[classIndexes[sortedSuffIndexesNew[i]]]] = sortedSuffIndexesNew[i];
    }

    classIndexesNew[sortedSuffIndexes[0]] = 0;
    nClasses = 1;
    for (int i = 1; i < len; ++i)
    {
        int firstStarter = (sortedSuffIndexes[i] + phazeLen) % len;
        int secondStarter = (sortedSuffIndexes[i - 1] + phazeLen) % len;
        if (classIndexes[sortedSuffIndexes[i]] != classIndexes[sortedSuffIndexes[i - 1]] 
            or classIndexes[firstStarter] != classIndexes[secondStarter])
        {
            ++nClasses;
        }
        classIndexesNew[sortedSuffIndexes[i]] = nClasses - 1;
    }

    delete [] classIndexes;
    delete [] sortedSuffIndexesNew;
    delete [] counter;

    classIndexes = classIndexesNew;
}

SuffixArray::LightArray SuffixArray::GetSuffixArray()
{
    return {sortedSuffIndexes, len};
}

SuffixArray::~SuffixArray()
{
    delete [] sortedSuffIndexes;
}

void SuffixArray::printInternal(int lineNum)
{
    printf("sortedSuffIndexes at %d:\n", lineNum);
    for (int i = 0; i < len; ++i)
    {
        printf("%3d) [%3d] %s$\n", i, sortedSuffIndexes[i], data + sortedSuffIndexes[i]);
    }
    printf("\n\n");
}

SuffixArray::LightArray SuffixArray::GetLCP()
{
    int* lcp = new int[len];
    int* reverseSuff = new int[len];

    for (int i = 0; i < len; ++i)
    {
        reverseSuff[sortedSuffIndexes[i]] = i;
    }

    int k = 0;
    for (int i = 0; i < len; ++i)
    {
        if (k > 0)
        {
            --k;
        }
        if (reverseSuff[i] == len - 1)
        {
            lcp[len - 1] = -1;
            k = 0;
            continue;
        }
        else
        {
            int j = sortedSuffIndexes[reverseSuff[i] + 1];
            while (std::max(i + k, j + k) < len and data[i + k] == data[j + k])
            {
                ++k;
            }
            lcp[reverseSuff[i]] = k;
        }
    }

    delete [] reverseSuff;

    ON_DEBUG(
        printf("sortedSuffIndexes\n");
        for (int i = 0; i < len; ++i)
        {
            printf("%3d) [id %3d, %3d common] %s$\n", i, sortedSuffIndexes[i], lcp[i], data + sortedSuffIndexes[i]);
        }
        printf("\n\n");
    )

    return {lcp, len};
}