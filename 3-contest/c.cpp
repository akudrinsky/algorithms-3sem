/*
Ученые работают на раскопках окаменелых останков древних существ на планете соседней звездной системы. В процессе исследования ученые пытаются понять, как именно цепочки ДНК различных существ составлялись из генов. 

Цепочки ДНК всех исследуемых существ представляют собой последовательности нуклеотидов. Каждый нуклеотид обозначется строчной буквой латинского алфавита. Таким образом, цепочка ДНК представляет собой строку, составленную из строчных букв латинского алфавита.

Ген также представляет собой строку из строчных букв латинского алфавита. Известно, что в любом корректном наборе генов никакая строка не является префиксом другой строки.

Будем говорить, что цепочку ДНК $$$d$$$ можно расшифровать с использованием набора генов $$$G$$$, если $$$d$$$ можно представить как результат последовательной записи одного или нескольких генов: $$$d = g_1g_2\ldots g_k$$$, где $$$g_i$$$ — гены из набора $$$G$$$. Один и тот же ген может входить в расшифровку ДНК несколько раз.</p><p>Для обработки информации ученым требуется разработать компьютерную систему, которая будет поддерживать корректный набор генов $$$G$$$ и массив цепочек ДНК существ $$$D$$$. По мере анализа останков, ученые могут добавлять новый ген в набор $$$G$$$ или добавлять новую цепочку ДНК в массив $$$D$$$. Гарантируется, что ни в какой момент времени не существует двух генов, один из которых является префиксом другого.

После каждой операции ученые хотят знать, какие цепочки ДНК в массиве $$$D$$$ можно расшифровать, используя текущий набор генов $$$G$$$. После $$$i$$$-й операции система должна сообщать $$$k_i$$$ — количество цепочек ДНК, находящихся в массиве $$$D$$$, которые впервые стало можно расшифровать после $$$i$$$-й операции, а затем $$$k_i$$$ чисел — номера этих цепочек. Результат очередной операции должен быть получен до того, как станет известна следующая операция.

Помогите ученым разработать такую систему.</p></div><div class="input-specification"><div class="section-title">Входные данные</div><p>В первой строке находится число $$$n$$$ — количество операций, которые необходимо выполнить ($$$1 \le n \le 100\,000$$$).

В следующих $$$n$$$ строках находятся описания операций, $$$i$$$-я строка начинается с символа «<span class="tex-font-style-tt">+</span>», если эта операция — добавление нового гена в набор $$$G$$$, или с символа «<span class="tex-font-style-tt">?</span>», если эта операция — добавление цепочки ДНК в конец массива $$$D$$$. Далее через пробел находится строка $$$x_i$$$, состоящая из строчных латинских букв, которую необходимо использовать, чтобы получить строку $$$s_i$$$, которая задает добавляемый в этой операции ген или цепочку ДНК.

Для получения строки $$$s_i$$$ из строки $$$x_i$$$, необходимо выполнить следующие действия. Если $$$i = 1$$$, то $$$s_i = x_i$$$. Иначе пусть число впервые расшифрованных цепочек ДНК после предыдущей операции равно $$$k_{i-1}$$$. Выполним $$$k_{i-1}$$$ раз следующее действие: перенесем первый символ $$$x_i$$$ в конец. Иначе говоря, выполним циклический сдвиг строки $$$x_i$$$ влево на $$$k_{i-1}$$$. Получившаяся строка равна $$$s_i$$$ — ген или цепочка ДНК, которую необходимо добавить на $$$i$$$-й операции.

Все строки не пусты, суммарный размер строк во всех операциях не превышает $$$10^6$$$.
Гарантируется, что ни в какой момент времени не существует двух генов, один из которых является префиксом другого.</p></div><div class="output-specification"><div class="section-title">Выходные данные</div><p>Выведите $$$n$$$ строк.

В $$$i$$$-й строке выведите сначала число $$$k_i$$$ — количество цепочек ДНК, находящихся в массиве $$$D$$$, которые впервые стало можно расшифровать после $$$i$$$-й операции, а затем $$$k_i$$$ чисел — номера этих цепочек. Цепочки нумеруются с единицы в порядке добавления в массив $$$D$$$. Номера цепочек в одной строке можно выводить в любом порядке.</p></div><div class="sample-tests"><div class="section-title">Пример</div><div class="sample-test"><div class="input"><div class="title">Входные данные</div><pre>
5
? abcabd
+ abc
? abcabc
? dabdab
+ abd
</pre></div><div class="output"><div class="title">Выходные данные</div><pre>
0
0 
1 2
0
2 1 3 
</pre></div></div></div><div class="note"><div class="section-title">Примечание</div><p>В первых трех операциях $$$s_1$$$, $$$s_2$$$ и $$$s_3$$$ совпавдают с соответствующими строками во вводе. Поскольку $$$k_3 = 1$$$, то для четвертой операции $$$s_4$$$ получается из строки $$$x_4=\mbox{«\texttt{dabdab}»}$$$ циклическим сдвигом влево на 1, таким образом, в четвертой операции в массив $$$D$$$ добавляется строка $$$s_4=\mbox{«\texttt{abdabd}»}$$$. Наконец, $$$k_4 = 0$$$, поэтому $$$s_5 = x_5$$$.</p></div></div><p>  </p></div>

*/

#include <algorithm>
#include <cstdio>
#include <vector>
#include <cstring>

class String {
public:
    String(char* notReversed, int len) 
        : 
        data(notReversed),
        length(len) {
        for (int i = 0; i < length / 2; ++i) {
            std::swap(data[i], data[len - i - 1]);
        }
    }

    String& operator=(const String& other) {
        memcpy(this, &other, sizeof(String));
        return *this;
    }

    char front() const {
        return data[length - 1];
    }

    void pop() {
        --length;
    }

    inline int len() const {
        return length;
    }

private:
    char* data;
    int length;
};

class StringBor {
public:
    StringBor(int nLetters) : nLetters(nLetters) {
        root = new Node(nLetters);
    }

    void NewString(String& str) {
        Node* cur = root;
        while (str.len() != 0) {
            if (cur->hasChild(str.front())) {
                // TODO: push old strings
                cur = cur->children[str.front()];
                str.pop();
            }
            else {
                cur->children[str.front()] = new Node(nLetters);
                cur = cur->children[str.front()];
                str.pop();
            }
        }
    }

    void checkString(String& str) {

    }

    class Node {
    public:
        Node(int nLetters) : nLetters(nLetters) {
            children = new Node*[nLetters];
        }

        ~Node() {
            for (int i = 0; i < nLetters; ++i) {
                delete children[i];
            }
            delete [] children;
            children = nullptr;
        }

        bool activeChildren() {
            return children != nullptr;
        }

        bool hasChild(int index) {
            return children[index] != nullptr;
        }

        bool& changePresense() {
            return isPresented;
        }

        bool& changeTerminal() {
            return isTerminal;
        }

    private:
        Node() : nLetters(0) {
            children = nullptr;
        }

        int nLetters;

        Node** children;

        bool isPresented;

        bool isTerminal;

        friend class StringBor;

    };

private:
    Node* root;
    const int nLetters;

};

int main() {
    int nRequests = 0;
    scanf("%d", &nRequests);

    // letter - 'a'

}